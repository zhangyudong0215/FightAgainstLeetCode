# FightAgainstLeetCode

Practice makes perfect

Python3 and Golang


## Finished:

|题号|类型|备注|
|:-:|:-:|:-:|
|1|||
|2|链表|涉及指针和地址，神奇的是居然用python做出来了，Go暂时没做|
|461|||
|\*617|递归|只做了golang的，python的条件没给全|
|657|||
|771|||
|728||函数式编程使代码更加清晰|
|561|排序|hashtable取代排序，个人认为是牺牲内存换取速度|
|476|位运算|要熟悉使用位运算符及其组合|
|557|字符串处理|Golang中string要转化为[]byte切片才能使用索引|
|344|字符串处理|翻转单词，可以看做557的铺垫|
|500|正则表达式|可以用字符串方法处理，但是RE更快|
|595|SQL||
|620|SQL||
|627|SQL|update, set语句修改值; case when then else条件语句|
|669|递归|要清楚binary search tree是二分查找的树|
|412|||
|682|||
|575|||
|566|矩阵维度转换|注意索引对齐|
|463||计算周长，有点意思|
|496|堆栈|现在的做法时间复杂度是O(n^2),Discuss中指出stack能够达到O(n)|
|637|二叉树|依然需要指针操作|
|521|字符串处理|很有趣，这道题说明思路比写代码更重要|
|693|位运算or字符串处理|同一个问题有多种思路|
|762|||
|292|||
|136|位运算|位运算代码简洁，但是此处速度不如迭代|
|104|递归, stack, deque|灵活使用数据结构|
|485|||
|226|递归, 二叉树||
|\*784|形似递归|完成python, Go未完成|
|520|字符串处理||
|690||hashtable用空间换时间，只支持python暂时不能用Go|
|695||计算面积，受到463题计算周长的启发|
|766||同一道题多种思路|
|258|数论？|这种问题思路最重要|
|283||注意时间复杂度，尽量维持算法高效|
|389||hashtable和^=位运算的应用|
|448||有点难，值得重复练习|
|371|位运算|完成Go语言，python这里对负数的操作完全无法理解|
|\*696||一开始没做出来，思路还是要灵活啊|
|788||转化为字符串操作|
|653|二分查找|广度搜索和深度搜索|
|606|递归|Golang居然是可以用"+"来连接字符串的！！！|
|717||多思考，答案其实很简单|
|\*538|递归|python没有指针，只能用数组的引用传递来替代|
|171|||
|598|||
|349|||
|453|||
|492|||
|169|||
|122|||
|13||罗马数字转换成int，没做无聊|
|733||我用递归做的，leetcode-in-go里大佬用类似广度搜索也行|
|100|递归|普普通通|
|404|递归|普通递归|
|242||Go的数组比切片还是快不少|
|383|||
|\*167||参考方法很巧妙；另外discuss中的大部分字典方法都没考虑存在类似4+4=8的情况|
||||
||||
||||
||||
||||
||||
||||
||||
||||
||||
||||
||||
||||
||||
||||
