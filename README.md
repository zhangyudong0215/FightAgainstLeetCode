# FightAgainstLeetCode

Practice makes perfect

Python3 and Golang


## Golang暂时未完成
526(动态规划, 赶时间没做)
805(始终报错)
451(没什么特别突出的方法, 就没想做)

## Finished:

|题号|类型|备注|
|:-:|:-:|:-:|
|1|||
|2|链表|涉及指针和地址，神奇的是居然用python做出来了，Go暂时没做|
|461|||
|\*617|递归|只做了golang的，python的条件没给全|
|657|||
|771|||
|728||函数式编程使代码更加清晰|
|561|排序|hashtable取代排序，个人认为是牺牲内存换取速度|
|476|位运算|要熟悉使用位运算符及其组合|
|557|字符串处理|Golang中string要转化为[]byte切片才能使用索引|
|344|字符串处理|翻转单词，可以看做557的铺垫|
|500|正则表达式|可以用字符串方法处理，但是RE更快|
|595|SQL||
|620|SQL||
|627|SQL|update, set语句修改值; case when then else条件语句|
|669|递归|要清楚binary search tree是二分查找的树|
|412|||
|682|||
|575|||
|566|矩阵维度转换|注意索引对齐|
|463||计算周长，有点意思|
|496|堆栈|现在的做法时间复杂度是O(n^2),Discuss中指出stack能够达到O(n)|
|637|二叉树|依然需要指针操作|
|521|字符串处理|很有趣，这道题说明思路比写代码更重要|
|693|位运算or字符串处理|同一个问题有多种思路|
|762|||
|292|||
|136|位运算|位运算代码简洁，但是此处速度不如迭代|
|104|递归, stack, deque|灵活使用数据结构|
|485|||
|226|递归, 二叉树||
|\*784|形似递归|完成python, Go未完成|
|520|字符串处理||
|690||hashtable用空间换时间，只支持python暂时不能用Go|
|695||计算面积，受到463题计算周长的启发|
|766||同一道题多种思路|
|258|数论？|这种问题思路最重要|
|283||注意时间复杂度，尽量维持算法高效|
|389||hashtable和^=位运算的应用|
|448||有点难，值得重复练习|
|371|位运算|完成Go语言，python这里对负数的操作完全无法理解|
|\*696||一开始没做出来，思路还是要灵活啊|
|788||转化为字符串操作|
|653|二分查找|广度搜索和深度搜索|
|606|递归|Golang居然是可以用"+"来连接字符串的！！！|
|717||多思考，答案其实很简单|
|\*538|递归|python没有指针，只能用数组的引用传递来替代|
|171|||
|598|||
|349|||
|453|||
|492|||
|169|||
|122|||
|13||罗马数字转换成int，没做无聊|
|733||我用递归做的，leetcode-in-go里大佬用类似广度搜索也行|
|100|递归|普普通通|
|404|递归|普通递归|
|242||Go的数组比切片还是快不少|
|383|||
|\*167||参考方法很巧妙；另外discuss中的大部分字典方法都没考虑存在类似4+4=8的情况|
|455|||
|387||更简单，更快，更省内存|
|\*530|二叉查找树|binary search tree可以转化为有序数组|
|237||这道题什么玩意儿|
|\*563|递归|关键是读懂题目的意思|
|217|||
|506|||
|697|||
|783|二叉查找树||
|206|链表 ListNode||
|599|||
|447|||
|661||暂时没找到Go的深复制方式|
|409|||
|\*543|二叉树|没做出来, 应该重复看|
|268||没意义的题,只完成了python|
|401||没啥意思|
|\*182|SQL|不会, 要补习一下mysql, 2018-3-12|
|628||本质是找出长度为n的数组中最大(小)的k个数字|
|744|||
|551||这道题不用各种内建方法也能用两个计数器完成|
|350||数组已排序时算法见笔记(用两个在数组上移动的tag)|
|\*108||有序数组转化为二分二叉树|
|796||很有意思 答案简洁&清晰|
|\*\*654|栈&递归|非常精彩的stack应用, 画图理解stack使用过程|
|\*797|递归&广度,深度搜索|go几种方法都没有实现|
|\*763||取补集, 返回不相交的几个集合的长度; Go程序未完成|
|537||复数乘法|
|419||Follow up也要尝试一下, 不难|
|\*338||参考方法对于二进制形式有较深理解|
|791||python和go均利用修改排序规则实现; 计数然后按顺序输出也行|
|442||注意条件的利用|
|\*406||成功完成, 但是有更好的方法; Go利用了类似791的自定义排序|
|513||参考方法是广度搜索; 自创方法也不错, 类似从left开始的广度搜索|
|540|类似二分搜索|独立完成!符合O(log(n))time&O(1)space要求|
|515|BFS&DFS|我只写了BFS的, DFS需要一个映射配合, 详见Go最快Accepted|
|553||It's a joke.|
|\*647|回文|discuss中的Manacher's Algorithm算法没看懂|
|413|||
|\*\*\*526|DP Dynamic Planning 动态规划|详细注释见python代码|
|\*260|位运算|竟然有这种方法?|
|739|栈|此问题Golang无论如何都是超时, Golang代码有Go中栈实现的技巧|
|508|||
|804||Weekly Contest 77|
|\*805|递归|<br/>Weekly Contest 77</br>进一步学习该怎么样递归|
|806||Weekly Contest 77|
|807||Weekly Contest 77|
|462||中位数|
|451||学习了collections.Counter.most_common方法|
|677|||
|495|||
|667|||
|\*\*712|DP|动态规划例题|
||||
||||
||||
||||
||||
||||
||||
||||
||||
